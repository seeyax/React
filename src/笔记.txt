
1.React是Web前端框架
  操作DOM思想:
    +操作DOM比较消耗性能[主要原因就是:可能会导致DOM重排(回流)/重绘]
    +操作起来也相对来讲麻烦一些
    +
  数据驱动思想：
    +我们不回再直接操作DOM
    +我们去操作数据[当我们修改了数据，框架会按照相关的数据，让页面重新渲染]
    +框架底层实现视图的渲染,也是基于操作DOM完成的
      +构建了一套 虚拟DOM->真实DOM 的渲染体系
      +有效避免了DOM的重排/重绘
    +开发效率更高、最后的性能也相对较好

2.React框架采用的是MVC体系,Vue框架采用的是MVVM体系;
  MVC:model数据层 + view视图层 + controller控制层   单向数据驱动：数据驱动视图的渲染
    @1 我们需要专业的语法去构建视图(页面):React中是基于jsx语法来构建视图的
    @2 构建数据层：但凡在视图中需要动态处理的(获取需要变化的，不管是样式还是内容),我们都要有对应的数据模型
    @3 控制层：当我们在视图中(或者根据业务需求)进行某些操作的时候,都是去修改相关的数据,然后React框架会按照最新的数据,重新渲染视图,
    以此让用户看到最新的效果

    总结：数据驱动视图的渲染
    视图中的表单内容改变,想要修改数据,需要开发者自己去写代码实现
    "单向驱动"
  MVVM: model数据层 + view视图层 + viewModel数据/视图监听层
   @1 数据驱动视图的渲染：监听数据的更新,让视图重新渲染
   @2 视图驱动数据的更改：监听页面中表单元素内容改变,自动去修改相关的数据

    总结："双向驱动"


JSX构建视图的基础知识
  JSX: javascript and xml 把JS和HTML标签混合在了一起(并不是我们之前玩的字符串拼接)
  @1 vscode如何支持JSX[格式化、快捷提示]……
    +创建的js文件,我们把后缀名设置为jsx即可,这样js文件中就可以支持JSX语法了
    +webpack打包的规则中,也是会对.jsx这类型文件,按照js的方式进行处理的
  @2 在HTML中嵌入JS表达式，需要基于"{}"
    +JS表达式：执行有结果的
  @3 在ReactDOM.createRoot()的时候，不能直接把HTML/body作为根容器，需要指定一个额外的盒子(例如：root)
  @4 每一个构建的视图，只能有一个根节点
    + React给我们提供了一个特殊的节点（标签）React.Fragment<></> 空文档标签
    + 既可以保证了可以只有一个根节点，又不新增一个HTML层级结构
  @5 {} 胡子语法中嵌入不同的值，所呈现出来的特点
    + number/string：值是啥，就渲染出来啥
    + boolean/null/undefined/Symbol/BigInt： 渲染的内容是空
    + 除数组对象外，其余对象一般都不支持在{}中进行渲染，但是也有特殊情况：
      + JSX虚拟DOM对象
      + 给元素设置style行内样式，要求必须写成一个对象格式
    + 数组对象：把数组的每一项都分别拿出来渲染[并不是变为字符串渲染，中间没有逗号]
    + 函数对象：不支持在{}中渲染，但是可以作为函数组件。用<Component/>方式渲染
  @6 给元素设置样式
    + 行内样式：需要基于对象的格式处理，直接写样式字符串会报错
      <h2 style={{color: 'red', fontSize: '20px'}}>我在学习React</h2> // 样式属性要基于驼峰命名法处理
    + 设置样式类名：需要把class替换为className

import React from 'react'; //React语法核心
import ReactDOM from 'react-dom/client'; //构建HTML(WebApp)的核心
// 获取页面中id为root的容器,作为根容器
const root = ReactDOM.createRoot(document.getElementById('root'));
// 基于render方法渲染我们编写的视图,把渲染后内容,全部插入到#root中进行渲染
root.render(
  <div>vfdvf</div>
)

关于JSX底层处理机制
  第一步：把我们编写的JSX语法，编译为虚拟DOM对象[virtualDOM]
    虚拟DOM对象：框架自己内部构建的一套对象体系(对象的相关成员都是React内部规定的)，基于这些属性描述出，我们所构建视图中的DOM节点的相关特性
    @1 基于babel-preset-react-app把JSX编译为React．createElement（．．．）这种格式
      只要是元素节点，必然会基于createElement进行处理
      +React.createElement(ele,props,...children)
        +ele:元素标签名[或组件名]
        +props：元素的属性集合（对象）[如果没有设置过任何的属性，则此值是null]
        +children: 第三个及以后的参数，都是当前元素的子节点
    @2 再把createElement方法执行,创建出virtualDOM[虚拟DOM对象(也有称之为JSX元素、JSX对象、ReactChild对象...)]
      + virtualDOM = {
        $$typeof:Symbol(react.element),
        ref: null,
        key: null,
        type: 标签名[或组件],
        // 存储了元素的相关属性&&子节点信息
        props: {
          元素的相关属性，
          children: 子节点信息[没有子节点则没有这个属性、属性值可能是一个值、也可能是一个数组]
        }
      }
  
  补充：胡子语法中，不能嵌入数组外的其他对象，但是有一个对象是可以直接嵌入的：JSX元素对象[虚拟DOM对象],我们可以直接基于createElement语法构建试图（比较麻烦）

  第二步:把构建的virtualDOM渲染为真实的DOM
    真实DOM：浏览器页面中，最后渲染出来，让用户看见的DOM元素
    基于ReactDOM中的render方法处理的
      v16：
        ReactDOM.render(
          <>...</>
          document.getElementById('root')
        )
      v18:
        const root = ReactDOM.createRoot(document.getElementById('root'))
        root.render(
          <>...</>
        )
  补充说明：第一次渲染页面是直接从virtualDOM->真实DOM；但是后期视图更新的时候，需要经过一个DOM-DIFF的对比，计算出补丁包PATCH（两次视图差异
  的部分），把PATCH补丁包进行渲染

 







